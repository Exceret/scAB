% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/12_scAB_class.R
\name{ComputeNormalizedLaplacian}
\alias{ComputeNormalizedLaplacian}
\title{Compute Normalized Graph Laplacian and Related Matrices}
\usage{
ComputeNormalizedLaplacian(A)
}
\arguments{
\item{A}{A square sparse adjacency matrix of class \code{"dgCMatrix"} (recommended) or coercible to it.
Typically represents a k-nearest neighbor (KNN) or shared nearest neighbor (SNN) graph.
Self-loops (diagonal entries) are automatically zeroed if present.
Non-zero entries are binarized to 1 (i.e., unweighted graph), consistent with common GNN/SNN usage.}
}
\value{
A list containing:
  \describe{
    \item{\code{L}}{The symmetric normalized graph Laplacian: \eqn{L = D_{\text{hat}} - A_{\text{hat}}}.
      Class \code{"dgCMatrix"}. For isolated nodes (degree = 0), the diagonal remains 0 (not 1),
      ensuring mathematical correctness: \eqn{L_{ii} = 0} when \eqn{\deg(i) = 0}.}
    \item{\code{Dhat}}{The normalized degree matrix: \eqn{D_{\text{hat}} = \text{diag}(d_1, \dots, d_n)},
      where \eqn{d_i = 1} if \eqn{\deg(i) > 0}, else \eqn{0}. Class \code{"ddiMatrix"} (diagonal).}
    \item{\code{Ahat}}{The symmetric normalized adjacency matrix:
      \eqn{(A_{\text{hat}})_{ij} = A_{ij} / \sqrt{\deg(i) \cdot \deg(j)}} for \eqn{A_{ij} \neq 0},
      and 0 otherwise. Class \code{"dgCMatrix"}.}
  }
}
\description{
This function computes the symmetric normalized graph Laplacian (\eqn{L = I - D^{-1/2} A D^{-1/2}}),
along with the normalized adjacency matrix (\eqn{A_{\text{hat}} = D^{-1/2} A D^{-1/2}}) and the
normalized degree matrix (\eqn{D_{\text{hat}} = D^{-1/2} D D^{-1/2}}), for a given sparse adjacency matrix.

The implementation is optimized for large-scale single-cell SNN graphs (e.g., Seurat's RNA_snn).
It avoids explicit sparse matrix multiplications (e.g., \code{D12 \%*\% A \%*\% D12}), which are
computationally expensive and may cause intermediate fill-in or memory explosion.
Instead, it directly manipulates the non-zero entries of \code{A} via its internal \code{dgCMatrix}
structure, achieving \eqn{O(\text{nnz}(A))} time complexity.
}
\details{
\strong{Key Optimizations and Numerical Safeguards:}
\enumerate{
  \item \strong{No Matrix Multiplications:} Instead of computing
    \code{D12 \%*\% A \%*\% D12} (which involves two sparse-sparse products),
    we directly scale each non-zero entry \eqn{A_{ij}} by \eqn{1/\sqrt{\deg(i) \cdot \deg(j)}}.
    This leverages the internal structure of \code{dgCMatrix}:
    \itemize{
      \item \code{A@i}: 0-based row indices of non-zeros.
      \item \code{A@p}: column pointers; \code{diff(A@p)} gives non-zero counts per column.
      \item \code{j_idx <- rep.int(seq_len(ncol(A)), diff(A@p))} efficiently constructs 1-based column indices
        without copying the full index matrix (critical for scalability).
    }
    Time complexity is strictly \eqn{O(\text{nnz}(A))}, with minimal memory overhead.

  \item \strong{Correct Handling of Isolated Nodes:}
    For a node \eqn{i} with \eqn{\deg(i) = 0}:
    \itemize{
      \item Its row/column in \code{A} is all zeros (after zeroing diagonal).
      \item \eqn{(D_{\text{hat}})_{ii} = (D^{-1/2} D D^{-1/2})_{ii} = 0}, since \eqn{D_{ii} = 0}.
      \item Thus, \eqn{L_{ii} = 0 - 0 = 0}, not 1.
    }
    The implementation sets \code{dhat_diag[i] <- 0} exactly when \code{degrees[i] == 0}.

  \item \strong{Numerical Stability:} A tiny epsilon (\eqn{\epsilon = 2.2204 \times 10^{-256}})
    is used to prevent division by zero when computing \eqn{1 / \sqrt{\deg(i)}}.
    Note: For any edge \eqn{(i,j)} with \eqn{A_{ij} \neq 0}, we have \eqn{\deg(i) \ge 1} and \eqn{\deg(j) \ge 1}
    (since degree is the sum of incident edges), so the scaling factor for existing edges is always finite.
    The epsilon only affects the (unused) scaling for zero-degree nodes, ensuring well-defined \code{deg_sqrt_inv}.
}

\strong{Assumptions:}
\itemize{
  \item Input matrix is square and represents an undirected graph (symmetry is not enforced but expected).
  \item Non-zero entries in \code{A} are positive (binarization sets them to 1).
}
}
\examples{
\dontrun{
# Simulate a small SNN graph (500 cells, 5\% sparsity, 50 isolated)
library(Matrix)
set.seed(123)
n <- 500
A <- rsparsematrix(n, n, density = 0.05)
A <- abs(A)  # Ensure positive weights
# Force 50 isolated nodes
A[(n-49):n, ] <- 0; A[, (n-49):n] <- 0
A <- as(A, "dgCMatrix")

res <- ComputeNormalizedLaplacian(A)
# Verify: L = Dhat - Ahat
stopifnot(all.equal(res$L, res$Dhat - res$Ahat, tolerance = 1e-12))
}

}
\keyword{internal}
